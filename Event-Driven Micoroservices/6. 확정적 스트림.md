# 확정적 스트림

- [1. 이벤트 기반 워크플로의 확장성](#1-이벤트-기반-워크플로의-확장성)
- [2. 타임스탬프](#2-타임스탬프)
  - [2.1. 분산 타임스탬프 동기화](#21-분산-타임스탬프-동기화)
  - [2.2. 타임스탬프 찍힌 이벤트 처리](#22-타임스탬프-찍힌-이벤트-처리)
- [3. 이벤트 스케줄링과 확정적 처리](#3-이벤트-스케줄링과-확정적-처리)
  - [3.1. 맞춤 이벤트 스케줄러](#31-맞춤-이벤트-스케줄러)
  - [3.2. 이벤트 시간, 처리 시간, 인입 시간에 따른 처리](#32-이벤트-시간-처리-시간-인입-시간에-따른-처리)
  - [3.3. 외부 시스템에 요청-응답 호출](#33-외부-시스템에-요청-응답-호출)
- [4. 워터마크](#4-워터마크)
  - [4.1. 병렬 처리시 워터마크](#41-병렬-처리시-워터마크)
- [5. 스트림시간](#5-스트림시간)
  - [5.1. 병럴 처리 시 스트림 시간](#51-병럴-처리-시-스트림-시간)
- [6. 비순차 이벤트와 지각 이벤트](#6-비순차-이벤트와-지각-이벤트)
  - [6.1. 워터마크와 스트림 시간이 늦은 이벤트](#61-워터마크와-스트림-시간이-늦은-이벤트)
  - [6.2. 비순차 이벤트의 원인과 영향](#62-비순차-이벤트의-원인과-영향)
  - [6.3. 시간에 민감한 함수와 윈도잉](#63-시간에-민감한-함수와-윈도잉)
- [7. 지각 이벤트 처리](#7-지각-이벤트-처리)
  - [7.1. 처리방법](#71-처리방법)
- [8. 재처리 대 준실시간 처리](#8-재처리-대-준실시간-처리)
- [9. 프로듀서/이벤트 브로커 연결 문제](#9-프로듀서이벤트-브로커-연결-문제)

## 1. 이벤트 기반 워크플로의 확장성

- 이벤트 처리방법

  - 실시간 처리
  - 캐치업 - 과거부터 이벤트를 처리해 현재를 따라잡음

- 어떤 식으로든 확정적 처리에서 가장 중요한 목표는 마이크로 서비스가 동일한 출력을 내는 것

## 2. 타임스탬프

- event time - 프로듀서가 이벤트에 할당한 타임스탬프
- broker ingestion time - 이벤트 브로커가 이벤트에 할당한 타임 스탬프
- consumer ingestion time - 컨슈머에 인입된 시간
- processing time - 컨슈머가 이벤트 처리를 완료한 시간

### 2.1. 분산 타임스탬프 동기화

- NTP 서버와 동기화 - 1ms 이하의 정확도가 가능

### 2.2. 타임스탬프 찍힌 이벤트 처리

- 타임스탬프를 활용해 분산된 이벤트를 일관된 시간 순서대로 처리
- 오프셋으로 비교하는 것은 단일 이벤트 스트림에서만 가능

## 3. 이벤트 스케줄링과 확정적 처리

- 이벤트를 일관되게 처리해야 나중에 확정적인 처리 결과를 재현 가능
- 어느 파티션에서 왔는지와 상관없이 레코드에 기록된 이벤트 시간에 따라 처리 순서를 interleaving 해야 함.

### 3.1. 맞춤 이벤트 스케줄러

- Apache Samza - MessageChooser를 구현해 이벤트 스트림간 우선순위, 이벤트 시간 등에 따라 처리할 이벤트를 선택 가능

### 3.2. 이벤트 시간, 처리 시간, 인입 시간에 따른 처리

- **이벤트 시간** 혹은 브로커 인입 시간을 기준으로 시간 순서대로 이벤트를 처리

### 3.3. 외부 시스템에 요청-응답 호출

- 외부 시스템은 요청에 대한 응답이 얼마든지 바뀔 수 있으므로 주의

## 4. 워터마크

- 처리 토폴로지를 안에서 시간 t 이전의 모든 이벤트가 처리 완료 됐음을 다운스트림 노드에게 알리는 신호.

### 4.1. 병렬 처리시 워터마크

- 각 컨슈머 인스턴스는 자신에게 할당된 파티션에서 이벤트를 가져와 groupByKey 함수와 aggreate 함수를 차례로 적용.
- 이 때 키가 같은 이벤트는 셔플하여 모두 동일한 다운스트림 aggregate 전달

1. 이벤트를 소비하며 증가하는 이벤트 시간을 워터마크에 기록해 다운스트림으로 보냄.
2. 워터마크가 도착하면 다운스트림 노든느 이벤트 시간을 업데이트하고 자신의 새로운 워트마크를 다시 전파
   1. aggregate는 입력 소스의 이벤트 시간 중 최소값을 워터마크로 보냄.
3. W(15)가 도달 하면 13->15로 업데이트

## 5. 스트림시간

- Stream Time - Apache Kafka Streams가 사용하는 시간
- 하나 이상의 이벤트 스트림에서 이벤트를 읽는 컨슈머 애플리케이션이 항상 가장 높은(최근의) 타임스탬프를 유지
- 완전히 처리 후 스트림 중에서 작은 타임스탬프의 이벤트를 먼저 처리

### 5.1. 병럴 처리 시 스트림 시간

- 내부 이벤트 스트림을 통해 이벤트 브로커에게 회송

## 6. 비순차 이벤트와 지각 이벤트

- out-of-order event - 이벤트 스트림에서 자신 앞의 이벤트보다 타임스탬프가 더 작은 이벤트
- 배치 처리를 하는 마이크로서비스는 비교적 유연하게 대처 가능, 배치 실행 전에 순서를 맞춰서 실행
- 그러므로 마이크로서비스에 따라 클럭 단위로 지각 이벤트가 있을 수도, 몇 시간 지난 이벤트도 지각이 아닌 것을 판단 할 수 있음.

### 6.1. 워터마크와 스트림 시간이 늦은 이벤트

- t > t'
- 워터마크 - 이벤트 t'이 W(t) 이후에 도착 하면 지각, 해당 노드가 알아서 처리.
- 스트림 - 스트림 시간이 t' 증가한 이후에 도착하면 지각 하위 토폴로지의 처리기가 알아서 처리.

### 6.2. 비순차 이벤트의 원인과 영향

- 비순차 데이터에서 소싱 - 원래부터 순서가 안맞으니 당연히 발생
- 여러 프로듀서가 여러 파티션으로
  - 리파티션 이벤트 스트림을 통해 이벤트 셔플링 중에 발생

### 6.3. 시간에 민감한 함수와 윈도잉

- 특정한 기간 동안 발생한 이벤트를 취합하거나 일정 시간이 경과하면 이벤트를 트리거
- Windowing - 이벤트를 시간에 따라 그룹핑
- 텀블링 윈도
  - 크기가 고정된 윈도
  - 윈도끼리 겹치지 않음
  - e.g. 사용자가 제품을 가장 많이 이용하는 시간대는?
- 슬라이딩 윈도
  - 크기는 고정
  - 슬라이딩 단계 만큼 겹침
  - e.g. 지난 한시간 동안 사용자의 수는?
- 세션 윈도
  - 크기가 동적으로 변함
  - 활동이 없으면 타임아웃 후 종료
  - 활동이 재개 되면 새로운 세션 생성
  - session gap - 세션 종료와 다음 세션 생성 사이의 간극

## 7. 지각 이벤트 처리

- 비순차 이벤트, 지각 이벤트 처리 전략은 데이터 중요도에 따라 달라지므므로 비지니스에서 결정되어야 함.
- 지연을 어느 정도까지 수용할지가 비즈니스 요건.
- 비즈니스 가이드 - 지각 이벤트를 기다리는 비용이 큰가? 혜택큰가?
  - 지각 이벤트 발생 가능성
  - 지연 시간의 길이
  - 이벤트 누락시 비즈니스 영향도
  - 지각 이벤트 처리시 비즈니스 이점

### 7.1. 처리방법

- 이벤트 폐기 - 그냥 이벤트를 버림.
- 대기
  - 일정 시간동안 윈도 결과를 늦춤.
  - 정해진 시간 안에서는 윈도 업데이트.
- 유예기간
  - 윈도가 완료되면 곧바로 출력.
  - 유예 기간동안 윈도를 가용상태로 놔둠.
  - 유예 기간 안에 지각 이벤트가 도착하면 결과 업데이트.

## 8. 재처리 대 준실시간 처리

- 재처리 - 불변 이벤트 스트림은 컨슈머 그룹의 오프셋을 되감아 임의의 시점부터 처리를 재연하는 것

1. 시적점 정하기 - 컨슈머가 구독하는 각 이벤트 스트림의 맨 처음부터 재처리
2. 어느 컨슈머 오프셍을 리셋할지 결정
3. 데이터량 확인
4. 재처리 시간 고려
5. 영향도 평가

## 9. 프로듀서/이벤트 브로커 연결 문제

- 프로듀서B의 갑작스런 네트워크 장애
- 스트림 A만 소비되면서 컨슈머는 증가됨
- 스트림 B에 이벤트가 적재되면 스트림에게는 지각 이벤트가 아니지만, 컨슈머에게는 지각 이벤트로 처리됨.
