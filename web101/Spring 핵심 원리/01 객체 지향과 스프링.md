# 객체 지향과 스프링

## 1. 스프링

### 1.1. 스프링이란?

- 여러 기술의 모음

- 필수

  - 스프링 프레임워크
  - 스프링 부트 - 여러 스프링 기술을 편리하게 사용할 수 있게 해 줌.

- 옵션
  - 스프링 데이터 - DB의 CRUD 지원
  - 스프링 세션 - 세션 기능을 편리하게
  - 스프링 시큐리티 - 보안
  - 스프링 Rest Docs - API문서화, 테스트
  - 스프링 배치 - 배치 처리 특화
  - 스프링 클라우드 - 클라우드 특화

### 1.2. 스프링 프레임워크

- **핵심 기술** - 스프링 DI 컨테이너, AOP, 이벤트 등등
- 웹 기술 - 스프링 MVC, 스프링 WebFlux
- 데이터 접근 기술 - 트랜잭션, JDBC, ORM 지원, XML 지원
- 기술 통합 - 캐시, 이메일, 원격 접근, 스케줄링
- 테스트 - 스프링 기반 테스트 지원
- 언어 - 코틀린, 그루비

### 1.3. 스프링 부트

- **스프링을 편리하게 사용할 수 있게 지원**
- 최근에는 기본으로 사용.
- 단독으로 실행할 수 있는 스프링 애플리케이션을 쉽게 생성.
  - Tomcat 웹 서버를 내장, 별도의 서버 설치 필요 없음.
- 손쉬운 빌드 구성을 위한 starter 종속성 제공.
- 스프링과 3rd part 라이브러리 자동 구성 - 버전 매칭을 자동으로 해 줌.
- 메트릭, 상태 확인, 외부 구성 같은 프로덕션 준비 기능 제공.
- 관례에 의한 **간결한 설정**.

### 1.4. 스프링 단어의 뜻

- 스프링 DI 컨테이너 기술
- 스프링 프레임워크
- 스프링 부트, 스프링 프레임워크 등을 모두 포함한 생태계

### 1.5. 왜 만들었나?

### 1.6. 핵심 콘셉트

- 자바(객체 지향) 언어 기반의 프레임워크
- **좋은 객체 지향 애플리케이션** 개발할 수 있는 프레임워크

## 2. 좋은 객체 지향

### 2.1. 객체 지향 특성

- 추상화
- 캡슐화
- 상속
- **다형성**

### 2.2. 객체 지향 프로그래밍

- 객체들의 모임
- 객체들은 메시지 주고받음.
- 객체들 데이터 처리
- 객체 변경 용이

### 2.3. 다형성

- 역할과 구현으로 구분
  - 단순해지고, 유연하고 변경이 용이해짐.
  - 클라이언트는 역할(인터페이스)만 알면 됨.
  - 클라이언트는 구현의 내부 구조를 몰라도 됨.
  - 클라이언트는 구현 대상이 변경되어도 영향을 받지 않음.

#### 2.3.1. 현실에 비유

- 운전자
- 자동차의 역할
- 자동차의 구현
  - K3, 아반떼, 테슬라
- 구현이 바뀌어도 역할을 할 수 있다.
- 역할을 분리한 것은 운전자를 위해서 한 것.
- 운전자는 구현을 신경 쓸 필요가 없음. 객체 변경 용이
- 운전자를 바꾸지 않고 그대로 자동차를 쓸 수 있음.

### 2.4. 역할과 구현을 분리

- 자바 언어의 다형성
  - 역할 - 인터페이스
  - 구현 - 인터페이스를 구현한 클래스.
- **역할을 먼저 부여하고, 역할을 수행하는 구현 객체 만들기**

- 객체의 협력 관계
  - 혼자 있는 객체는 없음.
  - 요청 - 클라이언트
  - 응답 - 서버

### 2.5. 자바 언어의 다형성

- polymorphism
  ![polymorphism](images/polymorphism.png)

- 오버라이딩 - 오버라이딩된 메서드가 실행.
- 다형성으로 인터페이스를 구현한 객체를 실행 시점에 유연하게 변경.
- 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경.

### 정리

- 실세계의 역할과 구현이라는 편리한 콘셉트를 다형성을 통해 가져 올 수 있음.
- 유연하고 변경이 용이
- 확장 가능한 설계
- 클라이언트에 영향을 주지 않는 변경 가능
- 인터페이스를 안정적으로 잘 설계하는 것이 중요.

### 한계

- 역할이 변하면 클라이언트, 서버 모두 큰 변경 발생.

### 스프링과 객체 지향

- 스프링은 다형성을 극대화.
- IoC, DI는 다형성을 편리하게 지원.

## SOLID

- SRP - Single Responsibility Principle 단일 책임 원칙
  - 한 클래스는 하나의 책임을 가짐.
  - 하나의 책임은 모호함. 문맥에 따라 다름.
  - 기준은 변경. 변경이 있을 때 파급 효과가 적으면 잘된 것.
  - eg) UI 변경, 객체의 생성과 사용을 분리.
- OCP - Open/Closed Principle 개방-폐쇄 원칙
  - 확장에는 열려있고, 변경에는 닫혀있음.
  - 다형성을 활용.
  - 인터페이스를 구현한 클래스를 교체하여 확장. 클라이언트는 변경이 없음.
  - 문제
    ```java
    MemberService.java
    // MemberRepository m = new MemoryMemberRepository(); // 기존 코드
    MemberRepository m = new JdbcMemberRepository(); // 변경 코드
    ```
    - 클라이언트 코드를 변경할 수밖에 없음.
    - 다형성으로 OCP를 지킬 수 없음.
  - 객체를 생성하고 연관관계를 맺어주는 *별도의 설정자*가 필요. = 스프링.
- LSP - Liskov Substitution Principle 리스코프 치환 원칙
  - 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스를 바꿀 수 있음.
  - 다형성에서 하위 클래스는 *인터페이스 규약*을 지켜야 한다.
  - 컴파일 성공을 넘어서 기능적으로 지켜져야 하는 것.
  - eg) 자동차 인터페이스의 엑셀은 앞으로 가야 한다. 뒤로 가면 LSP 위반.
- ISP - Interface Segregation Principle 인터페이스 분리 원칙
  - 특정 클라이언트를 위한 인터페이스 여러 개가 범용 인터페이스 하나보다 좋음.
    - 자동차 인터페이스 -> 운전 인터페이스, 정비 인터페이스로 분리.
    - 사용자 클라이언트 -> 운전자 클라이언트, 정비사 인터페이스로 분리.
  - 분리된 인터페이스끼리 영향을 주지 않음.
  - 인터페이스가 명확해지고 구현이 용이해져 대체 가능성이 높아짐.
- DIP - Dependency Inversion Principle 의존관계 역전 원칙
  - 프로그래머는 **추상화에 의존해야지, 구체화에 의존하면 안 된다.**
  - 구현 클래스에 의존하지 말고, 인터페이스에 의존하라는 뜻.
  - 역할(Role)에 의존하게 해야 한다.
  - 문제
    ```java
    MemberService.java
    MemberRepository m = new JdbcMemberRepository(); // 구현 클래스에도 의존. DIP위반.
    ```
  - 의존 - 그 코드를 직접 쓴다. 안다.

### 정리

- 객체 지향의 핵심은 다형성.
- 다형성 만으로 구현 객체를 변경할 때 클라이언트 코드도 함께 변경.
- 다형성만으로 OCP, DIP를 지킬 수 없음.
- 뭔가 더 필요하다. = 스프링

## 스프링

- DI, DI 컨테이너로 다형성, OCP, DIP를 가능하게 지원.
- 클라이언트 코드의 변경 없이 기능 확장.
- OCP, DIP 원칙을 개발하려면 배보다 배꼽이 더 크다. 프레임워크를 만듦.
- 순수하게 자바로 OCP, DIP 원칙을 지키면서 개발을 하면 DI 컨테이너(스프링 프레임워크)를 만들게 됨.

### 이상적

- 모든 설계에 인터페이스를 부여.

  - 구현 결정되지 않아도 개발을 할 수 있음.

- 단점
  - 추상화라는 비용이 발생.
  - 기능 확장 가능성이 없고, 구현이 결정 되었으면 구현 클래스를 사용하고, 인터페이스로 리펙토링하는 것도 방법.
