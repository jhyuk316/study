# 컴퓨터 내부의 언어 체계

- [언어란 무엇인가](#언어란-무엇인가)
- [문자 언어](#문자-언어)
- [비트](#비트)
- [논리 연산](#논리-연산)
  - [명제](#명제)
  - [불리언 대수 - Boolean algebra](#불리언-대수---boolean-algebra)
    - [진리표](#진리표)
  - [드모르간의 법칙](#드모르간의-법칙)
- [정수를 비트로 표현하는 방법](#정수를-비트로-표현하는-방법)
  - [양의 정수 표현](#양의-정수-표현)
  - [2진수 덧셈](#2진수-덧셈)
  - [음수 표현](#음수-표현)
    - [부호와 크기](#부호와-크기)
    - [1의 보수](#1의-보수)
    - [2의 보수](#2의-보수)
- [실수를 표현하는 방법](#실수를-표현하는-방법)
  - [고정소수점 표현법](#고정소수점-표현법)
  - [부동소수점 표현법](#부동소수점-표현법)
  - [IEEE 754 부동소수점 수 표준](#ieee-754-부동소수점-수-표준)
    - [특수한 표현](#특수한-표현)
    - [단정밀도](#단정밀도)
    - [배정밀도](#배정밀도)
- [2진 코드화한 10진수 시스템](#2진-코드화한-10진수-시스템)
- [2진수를 다루는 쉬운 방법](#2진수를-다루는-쉬운-방법)
  - [8진 표현법](#8진-표현법)
  - [16진 표현법](#16진-표현법)
  - [프로그래밍 언어의 진법 표기법](#프로그래밍-언어의-진법-표기법)
- [비트 그룹의 이름](#비트-그룹의-이름)
- [텍스트 표현](#텍스트-표현)
  - [아스키 코드](#아스키-코드)
  - [다른 표준의 진화](#다른-표준의-진화)
  - [유니코드 변환 형식 8비트](#유니코드-변환-형식-8비트)
- [문자를 사용한 수 표현](#문자를-사용한-수-표현)
  - [출력 가능하게 변경한 인코딩](#출력-가능하게-변경한-인코딩)
  - [베이스64 인코딩](#베이스64-인코딩)
  - [URL 인코딩](#url-인코딩)
- [색을 표현하는 방법](#색을-표현하는-방법)
  - [투명도 추가](#투명도-추가)
  - [색 인코딩](#색-인코딩)
- [출처](#출처)

## 언어란 무엇인가

- 모든 언어는 기호의 집합으로 **인코딩(Encoding)**
- 의사소통 당사자들이 모드 같은 **문맥(Context)**을 공유해서 같은 기호에 같은 뜻을 부여.

## 문자 언어

- 문자 언어는 기호를 나열한 것.
- 문자 언어의 틀
  - 기호가 들어갈 상자 - 문자
  - 상자에 들어갈 기호 - 알파벳, 형태소
  - 상자의 순서 - 위에서 아래, 왼쪽에서 오른쪽 혹은 그 반대

## 비트

- 비트 - 자연어의 상자에 해당
  > Bit = binary + digit
- 기호 - 추상적 해석, 꺼짐/켜짐, 낮/밤, 문맥에 따라 해석 하기 나름

## 논리 연산

- 비트로 True와 False을 표현.
- 논리 연산 - 다른 비트들이 표현하는 내용으로 새로운 비트를 만들어 내는 동작.

### 명제

- 논리적으로 뜻이 분명한 문장

### 불리언 대수 - Boolean algebra

- NOT - 반대
- AND - 모든 비트가 참 이면 참
- OR - 한 비트라도 참 이면 참
- XOR - 둘 중 하나만 참 이면 참

#### 진리표

![](images/1%20컴퓨터%20내부의%20언어%20체계_2023-02-18-12-00-48.png)

> https://www.realdigital.org/doc/e127ebfa82dbc904b5c0dac5d1adce8e

### 드모르간의 법칙

- a AND b = NOT(NOT a OR NOT b)
- `a && b == !(!a || !b)`

## 정수를 비트로 표현하는 방법

### 양의 정수 표현

- 10진수 체계 - 10가지 기호를 상자에 담음
- 각 상자는 오른쪽에서 부터 밑(base)이 10인 거듭제곱

- 5208

| 10³ | 10² | 10¹ | 10⁰ |
| --- | --- | --- | --- |
| 5   | 2   | 0   | 8   |

- 2진수로 표현
  - base가 2인 체계

| 2¹² | 2¹¹ | 2¹⁰ | 2⁹  | 2⁸  | 2⁷  | 2⁶  | 2⁵  | 2⁴  | 2³  | 2²  | 2¹  | 2⁰  |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |
| 1   | 0   | 0   | 1   | 1   | 1   | 0   | 1   | 0   | 0   | 1   | 0   | 0   |

- 숫자의 갯수가 표현 할 수 있는 값의 범위를 결정

  - 2³² = 4,294,967,296 개의 값을 표현

- LSM - Least significant bit. 가장 작은 유효 비트
- MSM - most significant bit. 가장 큰 유효 비트

- leading zero - 필요한 상자보다 상자가 많을 경우 왼쪽에 0을 채우는 것
  - 16비트 - 2진수 5208 - 0001 0011 1010 0100
  - 컴퓨터는 미리 정해진 수의 비트를 한 덩어리로 사용하도록 만들어저 있기 때문에 리딩 제로를 자주 사용함.

### 2진수 덧셈

- LSB에서 MSB로 올라가면서 덧셈

![](images/1%20컴퓨터%20내부의%20언어%20체계_2023-02-18-12-59-16.png)

- s - 두 수 더한 결과, XOR
- c - 올림, AND

![](images/1%20컴퓨터%20내부의%20언어%20체계_2023-02-18-13-00-22.png)

- 연산 결과 사용할 비트 갯수를 벗어나면 **오버플로우(Overflow)**가 발생
- 오버플로우 - MSB에서 올림이 발생 했다는 것.
- 컴퓨터에는 조건 코드 레지스터(Condition code register)가 있어 몇 가지 이상한 정보를 담어 둠.
- 오버플로 비트 - MSB에서 올림 값을 넣음. 오버플로 발생을 판단 할 수 있게 함.
- 언더플로우 - Underflow. MSB 위쪽에서 1을 빌려오면 발생

### 음수 표현

#### 부호와 크기

- MSB를 부호로 사용
- 나머지는 기존의 2진수 표현법
- 문제 - 덧셈 연산이 바로 되지 않음. 음수와 양수를 더하면 원하는 결과가 나오지 않음.

#### 1의 보수

- 양수을 모두 뒤집는 표현
- 음수 = NOT(양수)
- -0이 존재
- 문제 - 덧셈연산시 MSB의 올림을 LSB로 전달해야 함.

#### 2의 보수

- 양수를 뒤집고 +1
- 음수 = NOT(양수) + 1
- 덧셈 연산이 바로 됨.
- 2의 보수로 표현 할 수 있는 범위
  - 2³² = -2³¹ ~ 2³¹ - 1

> 같은 1111 비트 라도  
> 부호와 크기법에서는 -7,  
> 1의 보수에서는 -0,  
> 2의 보수에서는 -1,  
> 을 나타낸다.

## 실수를 표현하는 방법

### 고정소수점 표현법

- 소수점 왼쪽과 오른쪽 비트수를 고정

### 부동소수점 표현법

### IEEE 754 부동소수점 수 표준

- 구성
  - 부호 - sign, s, 부호
  - 가수부 - biased exponent, 지수
  - 실수부 - fraction, 유효 숫자
- 실수부는 첫비트가 1로 가정해서 비트 수를 아낌.

#### 특수한 표현

- Zero
  - 부호, biased exponent = 0, fraction 0
- 무한대
  - ∞ - 부호, biased exponent 모두 1, fraction 0
- NaN
  - Not a Number
  - `s111 1111 1xxx xxxx xxxx xxxx xxxx xxxx`
  - x는 모두가 0이면 안됨. 에러 유형 표시

#### 단정밀도

- 부호 - 1bit
- 가수부 - 8bit - -126 ~ 127
- 실수부 - 24bit
- 정밀도 - 7.22자리 숫자

#### 배정밀도

- 부호 - 1bit
- 가수부 - 11bit
- 실수부 - 53bit
- 정밀도 - 15.95자리 숫자

## 2진 코드화한 10진수 시스템

- BCD
- 4비트를 1자리 숫자로 표현
- 4비트는 16까지 표현 가능하므로 효율이 안좋음.
- 계산도 복잡함.

## 2진수를 다루는 쉬운 방법

### 8진 표현법

- 비트를 3개씩 그룹으로 묶음
- 000

### 16진 표현법

- 비트를 4개씩 그룹
- 컴퓨터는 내부적으로 8비트의 배수를 사용
- 0000
- 10진수 10 ~ 15는 A ~ F로 표현

### 프로그래밍 언어의 진법 표기법

- 여러 언어들의 관례
- 2진수 - 0b로 시작 eg. 0b0010
- 8진수 - 0으로 시작 eg. 0070
- 10진수 - 1~9로 시작 eg. 123
- 16진수 - 0x로 시작 eg. 0xA0

## 비트 그룹의 이름

- 비트 단위는 너무 작기 때문에 효율을 위해서 기본 덩어리를 정해서 처리.

| 이름                   | 비트 개수 |
| ---------------------- | --------- |
| 니블(nibble)           | 4         |
| 바이트(byte)           | 8         |
| 하프 워드(half word)   | 16        |
| 워드(word)             | 32        |
| 더블 워드(double word) | 64        |

## 텍스트 표현

### 아스키 코드

- ASCII - American Standard Code for Information Interchange, 정보 교환을 위한 미국 표준 코드
- 키보드의 모든 기호에 대해 7비트 수 값을 할당

![](images/1%20컴퓨터%20내부의%20언어%20체계_2023-02-23-23-01-18.png)

- 제어문자

![](images/1%20컴퓨터%20내부의%20언어%20체계_2023-02-23-23-04-15.png)

- Extended ASCII characters는 ISO 8859-1dp를 따르며 ISO Latin-1로도 불립니다.

![](images/1%20컴퓨터%20내부의%20언어%20체계_2023-02-23-23-01-24.png)

### 다른 표준의 진화

- 여러 나라에서 컴퓨터를 사용하게 되면서 표준이 늘어남
- 비트가 비싸기 때문에 7~8비트에 밀어 넣는 형태의 표준이 등장
- KS C 5601 - 한국어

- 유니코드
- 세상에 모든 문자를 하나의 표준에 넣기 위해서 16비트로 지정
- 하지만 21비트까지 확장됨.
- 이모지 등으로 더 확장 될 수도 있음.

### 유니코드 변환 형식 8비트

- 인코딩 - 다른 비트 패턴을 표현하기 위해 사요하는 비트 패턴
- UTF-8
- Unicode Transformation Format-8 bit
- 유니코드 변환 형식.
- 모든 아스키 문자를 8비트로 표현 아스키 데이터를 인코딩 할때는 별도의 공간이 필요하지 않음.
- 아스키가 아닌 문자의 경우 아스키를 받아서 처리하는 프로그램이 깨지지 않는 방법으로 문자를 인코딩.
- 8비트 덩어리를 시퀀스로 인코딩
- MSB쪽 비트들이 8비트 덩어리 시퀀스의 길이를 표현

| 유니코드  |                                        | utf-8로 저장하는 값 |             |             |             |
| :-------: | :------------------------------------: | :-----------------: | :---------: | :---------: | :---------: |
|  자릿수   |              코드값 범위               |      첫 바이트      | 둘째 바이트 | 셋째 바이트 | 넷째 바이트 |
| 00~07비트 |              0 ~ 0x7F 127              |      0xxxxxxx       |             |             |             |
| 08~11비트 |         0x80 128 ~ 0x7FF 2,047         |      110xxxxx       |  10xxxxxx   |             |             |
| 12~16비트 |      0x800 2,048 ~ 0xFFFF 65,535       |      1110xxxx       |  10xxxxxx   |  10xxxxxx   |             |
| 17~21비트 | 0x10000 65,536 ~ 0x1FFFFF 2,097,151[3] |      11110xxx       |  10xxxxxx   |  10xxxxxx   |  10xxxxxx   |

![](images/1%20컴퓨터%20내부의%20언어%20체계_2023-02-25-13-06-39.png)

## 문자를 사용한 수 표현

- 2진 데이터를 직접 보내는 것은 쉽지 않음.
- 아스키 코드 중 상당 수가 제어 문자로 예약.
- 7비트만 송수신 가능한 시스템 존재.

### 출력 가능하게 변경한 인코딩

- Quoted-Printable encoding
- 8비트 데이터를 7비트 데이터만 지원하는 통신 경로로 송수신하기 위한 인코딩 방법
- 전자 우편 첨부를 처리하기 위해 만들어짐.

```qp
=3D =
```

- = 다음에 바이트를 각 니블을 표현하는 16진 숫자 2개를 추가해 8비트 값을 표기
- 한 줄에 76자 제한
- 어떤 줄 맨 뒤가 = 이면 가짜 줄 바꿈 QP에서는 이를 제거하고 해석
- 1바이트를 3바이트로 표현

### 베이스64 인코딩

- 3바이트 데이터를 4바이트로 표현
- 3바이트 데이터의 24비트를 4등분해 6비트 덩어리로 나누고,  
  각 덩어리의 6비트값에 축렭가능한 문자를 할당해 표현
- = - 패딩 문자
- 3의 배수가 아니면 배딩 문자를 붙임.
- 1바이트 데이터 패딩

  ![](images/1%20컴퓨터%20내부의%20언어%20체계_2023-02-25-14-45-00.png)

- 2바이트 데이터 패딩

  ![](images/1%20컴퓨터%20내부의%20언어%20체계_2023-02-25-14-44-43.png)

| Index | Binary | Char | Index | Binary | Char | Index | Binary | Char | Index | Binary | Char |
| :---: | :----: | :--: | :---: | :----: | :--: | :---: | :----: | :--: | :---: | :----: | :--: |
|   0   | 000000 |  A   |  16   | 010000 |  Q   |  32   | 100000 |  g   |  48   | 110000 |  w   |
|   1   | 000001 |  B   |  17   | 010001 |  R   |  33   | 100001 |  h   |  49   | 110001 |  x   |
|   2   | 000010 |  C   |  18   | 010010 |  S   |  34   | 100010 |  i   |  50   | 110010 |  y   |
|   3   | 000011 |  D   |  19   | 010011 |  T   |  35   | 100011 |  j   |  51   | 110011 |  z   |
|   4   | 000100 |  E   |  20   | 010100 |  U   |  36   | 100100 |  k   |  52   | 110100 |  0   |
|   5   | 000101 |  F   |  21   | 010101 |  V   |  37   | 100101 |  l   |  53   | 110101 |  1   |
|   6   | 000110 |  G   |  22   | 010110 |  W   |  38   | 100110 |  m   |  54   | 110110 |  2   |
|   7   | 000111 |  H   |  23   | 010111 |  X   |  39   | 100111 |  n   |  55   | 110111 |  3   |
|   8   | 001000 |  I   |  24   | 011000 |  Y   |  40   | 101000 |  o   |  56   | 111000 |  4   |
|   9   | 001001 |  J   |  25   | 011001 |  Z   |  41   | 101001 |  p   |  57   | 111001 |  5   |
|  10   | 001010 |  K   |  26   | 011010 |  a   |  42   | 101010 |  q   |  58   | 111010 |  6   |
|  11   | 001011 |  L   |  27   | 011011 |  b   |  43   | 101011 |  r   |  59   | 111011 |  7   |
|  12   | 001100 |  M   |  28   | 011100 |  c   |  44   | 101100 |  s   |  60   | 111100 |  8   |
|  13   | 001101 |  N   |  29   | 011101 |  d   |  45   | 101101 |  t   |  61   | 111101 |  9   |
|  14   | 001110 |  O   |  30   | 011110 |  e   |  46   | 101110 |  u   |  62   | 111110 |  +   |
|  15   | 001111 |  P   |  31   | 011111 |  f   |  47   | 101111 |  v   |  63   | 111111 |  /   |

### URL 인코딩

- URL에서 특별한 의미를 가지는 문자를 literal로 사용
- 문자 그대로 출력할 필요가 있음.
- 퍼센트 인코딩 - Percent-encoding
- %뒤에 16비트를 표현
- 예시
  - URL에서 /는 경로를 표기
  - 하지만 /를 그대로 표현 하고 싶으면 %2F를 사용.
  - % - %25

## 색을 표현하는 방법

- Pixel - pictural element
- RGB 모델 - 빛의 3원색
- Color cube - 각 축은 primary 색을 표현
- Additive 색 시스템 - 빛의 3원색
- Subtractive 색 시스템 - 색의 3원색
- Prepress - Additive 색 시스템과 Subtractive 색 시스템에서 같은 색을 표현하는 기술

- 24비트 색상 시스템
  - 1천만 색상 표현
  - 8비트 3개로 색 표현
  - RGB
  - 24비트는 컴퓨터 친화적이지 않음
- 32비트 색상 시스템
  - 24비트에 가장 근접한 비트 그룹
  - 투명도에 8비트를 할당해서 사용
  - RGBA

### 투명도 추가

- 1980년대에 투명도로 합성(compose) 가능해짐.
- 합성 계산법 - Compositing algebra
- 더프와 포스터 방법
- 알파값을 미리 곱한 값으로 RGB 표현

### 색 인코딩

- 16진 트리플셋
- #000000 검은색
- #ffffff 흰색

- 웹은 알파를 다른 방식으로 표현
  - 요즘 브라우저들은 지원
  - #FFFF, #FFFFFFFF 같은 형태

---

## 출처

- Representations of Logic Operations - https://www.realdigital.org/doc/e127ebfa82dbc904b5c0dac5d1adce8e
- 전가산기(Full adder) - https://blog.naver.com/PostView.naver?blogId=asd7979&logNo=30108683862
- https://en.wikipedia.org/wiki/IEEE_754
- 아스키코드(ASCII)와 확장아스키코드(Extended ASCII)에 대하여 - https://developer-p.tistory.com/72
- ASCII 제어 문자 표 (0~31) - https://cs10.tistory.com/29
